\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{color}
\usepackage{babel}
\usepackage{amsmath}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}

\makeatletter


\providecommand{\tabularnewline}{\\}

%% guys don't worry about names being in the date section,
%% I did it so that  I could arange it in the order with sub title

\date{Amin Saeidi, Shlomo Georg Konwisser and Aaditya Prakash}
\usepackage{graphicx}
\hypersetup{urlcolor=blue}

\makeatother

\begin{document}

\title{Detection of fallacy in natural text}

%% see the comment above for the date section
\author{Final project for CS135: Computational Semantics}

\maketitle

\section{Abstract}

In this project we investigate and build a simple fallacy detection
system in Haskell from natural text. This project implements relation
extraction at level sufficient to allow for conversion of natural
text into logical form. Once the logical form is obtained, a tautological
relation of the propositional fallacy is exploited to deduce if the
given logical expression contains a fallacy. Because of the forementioned
fact, this project is limited to propositional fallacies only and
does not support other types of fallacies, for example quantification
fallacies and formal syllogistic fallacies. It has been aimed to keep
the parsed input as a free natural text but certain constrained and
structure has been assumed.


\section{Design}

After careful thought and experimenation with several Haskell packages
for First Order Logic conversion ( \href{https://github.com/traeger/fol-solver}{FOL Solver},
\href{https://github.com/marcosccm/enki}{Haskell Inference Engine},
\href{https://github.com/edwinb/Ivor}{Type Theory based theorem prover},
\href{https://github.com/danr/hip}{Haskell Inductive Prover}, \href{http://attempto.ifi.uzh.ch/site/}{University of Zurich's Attempto Project}
and \href{http://homepages.cwi.nl/~jve/courses/12/haskellroad/TOTP.pdf}{Jan van Eijck's TOTP}),
we decided to write our own relation extraction customized for fallacy
proving. There were several reasons for this decision, but few of
them were -

1. Converstion to first order logic, was an overkill for our purposed

2. Most of the libraries we experimented, had their fair share of
issues with compatibility, execution or performance.

3. We wanted to put into practice some of the semantics knowledge
obtained from this class.


\subsection{Converting sentences to logical form}

One of the major challenges of this project was to be able to write
down the provided set of sentences into logical form of simplified
knowledge sets as premises and a conclusion. It was important to track
the modifiers. As mentioned earlier in Abstract, we decided to focus
only on propositional fallacies, thus we did not have to deal with
quantifiers. Following schematic logic was used to convert the text
to logical form.
\begin{enumerate}
\item Take the sentence 
\item Set the boundaries so that seperate knowledge can be extracted. Replace
the following explicit logic operators -

\begin{enumerate}
\item AND \textquotedbl{}but\textquotedbl{} with keyword \textquotedbl{}and\textquotedbl{}
\textquotedbl{}.\textquotedbl{} with keyword \textquotedbl{}and\textquotedbl{} 
\item IMPLICATION \textquotedbl{}therefore\textquotedbl{} with \textquotedbl{}=>\textquotedbl{}
\textquotedbl{}so\textquotedbl{} with \textquotedbl{}=>\textquotedbl{} 
\end{enumerate}
\item Stem the Sentence as a whole (just normal stemming and not chunking)
(Stemming seperates the sentences with \textquotedbl{}.\textquotedbl{}
as different array elements so that we get different knowledge set
for separate variable) 
\item Tag the sentence (stemming before so that we get the same tags for
the same verb but represented in different format) 
\item Extract the premise and the conclusion part. 
\item Make the premise and the conclusion part, separately into well formed
expression 

\begin{enumerate}
\item Find, NOT in the proposition, extract and apply it to the proposition
as unary operator 
\item Recursively apply OR (Disjunction) and AND (Conjunction) to the list
of propositions variables 
\end{enumerate}
\end{enumerate}

\subsection{Detecting fallacy from logical form}

Once the given set of sentences were converted into logical form,
we used the tautological expression obtained from satisfiability of
the given set of premises implying the given conclusion as a test
of given fallacy. We have exploited the \href{http://en.wikipedia.org/wiki/Tautology_(logic)}{definition of tautology in propositional logic},
which extends it to any logically valid formula. Therefore we have
tested for tautology for the given set of premises and conclusion
impliying the given structure of fallacy (also represented in propositional
logic). 


\section{Fallacies implemented}

We have implemented the detection of following propositonal fallacies-


\subsection{Affirming the disjunct}

Affirming the disjunct is a type of fallacy which occurs when one
of the logical expression in a set of disjuncts is concluded to be
false in the evidence of another premise. In logical formula, this
is expressed as follows:

\begin{center}
$p\vee q$
\par\end{center}

\begin{center}
$p$
\par\end{center}

\begin{center}
$\implies\neg q$
\par\end{center}

Example of this type of fallacy from Wikipedia: 

\begin{center}
Max is a cat or Max is a mammal.
\par\end{center}

\begin{center}
Max is a cat.
\par\end{center}

\begin{center}
Therefore, Max is not a mammal.
\par\end{center}

Following is the screenshot of parsing the above example in our program.

\begin{figure}[htp]
\makebox[\textwidth][c]{\includegraphics[width=1.3\textwidth]{disjunct}} \caption{Detecting affirming the disjunct} \end{figure}


\subsection{Affirming the consequent}

Affirming the consequent fallacy occurs when given a conditional and
a premise assumes the validity of the consequent. In logical form
this can be expressed as follows:

\begin{center}
$p\to q$
\par\end{center}

\begin{center}
$q$
\par\end{center}

\begin{center}
$\implies p$
\par\end{center}

Example of this type of fallacy from Wikipedia: 

\begin{center}
If Bill Gates owns Fort Knox, then he is rich.
\par\end{center}

\begin{center}
Bill Gates is rich.
\par\end{center}

\begin{center}
Therefore, Bill Gates owns Fort Knox.
\par\end{center}

Following is the screensho of parsing the above example (without anaphora
resolution) in our program:

\begin{figure}[htp]
\makebox[\textwidth][c]{\includegraphics[width=1.3\textwidth]{consequent}} \caption{Detecting affirming the consequent} \end{figure}


\subsection{Denying the antecedent}

Denying the antecedent is similar in strucutre to affirming the consequent
but different in intepretation. In denying the antecedent, given a
conditional and invalidity of the antecedent, fallacy is to assume
invalidity of consequent. In logical form this can be expressed as
follows:

\begin{center}
$p\to q$
\par\end{center}

\begin{center}
$\neg p$
\par\end{center}

\begin{center}
$\implies\neg q$
\par\end{center}

Example of this type of fallacy from Wikipedia: 

\begin{center}
If Queen Elizabeth is an American citizen, then she is a human being.
\par\end{center}

\begin{center}
Queen Elizabeth is not an American citizen.
\par\end{center}

\begin{center}
Therefore, Queen Elizabeth is not a human being.
\par\end{center}

Following is the screensho of parsing the above example (without anaphora
resolution) in our program:

\begin{figure}[htp]
\makebox[\textwidth][c]{\includegraphics[width=1.4\textwidth]{antecedent}} \caption{Detecting denying the antecedent} \end{figure}


\section{Code}

A brief description of each of the haskell file has been provided
below. For detailed analsis, kindly refer to the function headers
and inline comments in those code files.

\medskip{}


\begin{tabular}{rl}
Source & Description\tabularnewline
\hline 
Main.hs & Serves as the entry point of the application. See README.md{*} for
usage.\tabularnewline
Detector.hs & Checks for fallacy, when provided with expression in propositional
logic.\tabularnewline
LogicalShortcuts.hs & Makes shortcuts for the logical operations in propostional logic.\tabularnewline
Tests.hs & Includes the unit tests for different modules of the application.\tabularnewline
TextToLogical.hs & Converts the given natural text into propositional logic form for
the fallacy.\tabularnewline
\end{tabular}

\medskip{}


{*}On the root folder of the submission, README.md file has been provided
with detailed instruction on running the modules and the unit tests.


\section{Further Work}

We see this as start of the project and envision this to extend for
all kinds of fallacies and for much wider acceptance of text. We have
also been working on anaphora resolution, so that simpler pronouns
in the given premise may be bound to same knowledge set. Another immediate
extension would be to extend this from propositional logic to first
order logic so that quantification fallacies like existential fallacy
could be detected. We also aim to make the parser work with implicit
conclusion rather than explicit conclusion with verbal cues. 
\end{document}
